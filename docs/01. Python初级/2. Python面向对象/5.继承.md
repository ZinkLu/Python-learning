# 05.继承

## 目标
- 单继承
- 多继承

面向对象的三大特性
1. **封装** 根据职责将**属性和方法**封装到一个抽象的**类**中
2. **继承** 实现**代码的重用**，相同的代码不需要重复编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**


<br/>
<br/>
<br/>

## 1、单继承

### 1.1 继承的概念，语法和特点

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

#### 1）继承的语法

```python
# python
class 子类名(父类名)：
    pass
```

```swift
// swift
class SubClass:SpuerClass{
    
}
```

#### 2）专业术语

- `Dog`类是`Animal`的子类，`Animal`是`Dog`类的父类，`Dog`类从`Animal`类继承

- `Dog`类是`Animal`类的派生类，`Animal`类是`Dog`类的基类，`Dog`类是从`Animal`类派生

#### 3）继承的传递性

- `C`类从`B`类继承，`B`类又从`A`类继承

- 那么`C`类就具有`B`类和`A`类的所有属性和方法

**子类**拥有**父类**以及**父类的父类**中封装的所有属性和方法

### 1.2 方法的重写

- **子类**拥有**父类**的所有**方法和属性**

- **子类**继承自**父类**，可以直接享受父类中已经封装好的方法，不需要再次开发

- 这种方法叫做**重写Override**

重写父类方法有两种情况：

1. **覆盖**父类的方法

2. 对父类方法进行**拓展**

**1）覆盖父类的方法**

- 如果在开发中，**父类的方法实现**和**子类方法实现**完全不同

- 就可以使用**覆盖**的方式，**在子类中 重新编写**父类的方法实现

> *具体的实现方式，就相当于在<b>子类中**定义了一个和父类<b>同名的方法**并且实现*

重写之后，在运行时，只会调用子类中重写的方法，而不会再调用父类封装的方法
> 在swift中如何重写？`override`关键字 还有重写属性的击中方法

**2）拓展父类的方法**
- 如果在开发中，子类的方法实现中包含父类的方法实现
    - 父类原本封装的方法实现是子类方法的一部分
- 就可以使用**拓展**的方式
    1. 在子类中重写父类的方法
    2. 在需要的位置使用`super().父类方法()`来调用父类方法的执行 - 只有pyhton3
    3. 代码其他的位置针对子类的需求，编写**子类特有的代码实现**

**关于super**
- `super`是一个特殊的类
- `super()`就是使用super类创建出来的对象

> 有关于super在swift中的使用，super可以在重写父类方法或属性时，调用原有的方法和属性。好像差不多！<br> 但是在swift中，super使用和self一样，不需要`super()`

**调用父类方法的另外两种方式**
> 在`Python 2.x`时，如果需要条用父类的方法，还可以使用以下方法

```python
父类名.方法(self)
```

```python
super(子类名, self).父类方法()
```

- `3.x` 中虽然支持，但不推荐

提示
- 在开发时，`父类名`和`super()`两种方式不要混用
- 如果使用当前子类名调用方法，会形成递归调用，出现**死循环**

### 1.3 父类的私有属性和私有方法
1. 子类对象 不能在自己的方法内部直接访问父类的**私有属性或私有方法**
2. 子类对象 可以通过**父类**的**共有方法 间接**访问到**私有属性**或**私有方法**

> - **私有属性、方法** 是对象的隐私，不对外公开，外界以及子类都**不能直接访问**
> - **私有属性、方法** 通常用于做 **内部** 的事情

<br>
<br>
<br>

## 2、多继承
概念
- 子类可以继承自**多个父类**，并且具有**所有父类的属性和方法**
```python
# python
class 子类名(父类1, 父类2)：
    pass
```
```swift
// swift
class SubClass:Protcol:SpuerClass1:SuperClass2{
    
}
```
### 2.1 多继承的使用注意事项
问题的提出
- 如果不同的父类中存在**同名的方法**，子类对象在再用方法时，会调用哪一个父类中的方法呢？
> tip：开发时，应该尽量避免这种情况。

**Python中的MRO--方法搜索顺序**
- `Python`中针对类提供了一个**内置属性** `__mro__`可以查看方法搜索顺序
- MRO是`method resolution order`，主要用于在多继承时判断方法、属性的**调用路径**
```python
class A:
    pass
    
class B:
    pass
    
class C(B,A):
    pass

print(C.__MRO__)

# (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
# 先搜索C类中的方法、在搜索B类中的方法、再搜索A类中的方法，最后搜索基类-object类中的方法，都找不到的话就报错了

```
### 2.2 新式类与旧式（经典）类
> `object`是`Python`为所有对象提供的**基类**，提供有一些内置的属性和方法，可以使用`dir`函数查看

- **新式类**：以`object`为基类的类，推荐使用
- **经典类**：不以`object`为基类的类，不推荐使用
- 在Python3中定义类时，如果没有指定父类，会默认使用`object`作为该类的基类

> 为了保证编写的代码能够同时在`Python2`和`Python3`中都能运行，今后在定义类时，如果没有父类，建议统一继承自`object`