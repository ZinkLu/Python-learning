## 目标
- 多态

面向对象的三大特征

1. **封装** 根据职责将**属性和方法**封装到一个抽象的**类**中

2. **继承** 实现**代码的重用**，相同的代码不需要重复编写

3. **多态** **不同的子类对象**调用**相同的父类方法**，产生**不同的执行结果**
    - 多态可以**增加代码灵活度**
    - 以**继承**和**重写**父类方法为前提
    - 是调用方法的技巧，不会影响到**类的内部设计**


> 7月22日：下面代码，多态的功能和协议差不多，但是多态的实现并不是强制性的
>
> 事实上...Swift必须使用**协议**才能实现多态...因为Swift是类型安全的语言，不能将不同类的实例当做参数传入
>
> Swift中如果想要实现多态，必须让不同的类遵循相同的协议，然后再让想要调用类的一方设定方法，将协议作为参数传入，这样，只要遵循协议的实例都能传进来了。
>
> 在类类之间调用的时候，如果想让调用更加的灵活，这不就是代理设计模式么...

<br>

```python
# 这一个父类存在的价值就是保证了调用的安全
class Dog(object):
    def work(self):
        pass

class Dog1(Dog):
    def work(self):
        print("Dog1 work")

class Dog2(Dog):
    def work(self):
        print("Dog2 work")

class Person(object):
    # 真正的差别出现了， Python的参数不指定传入变量的类型，所以所有对象都可以传入，如果没有work方法，则程序报错
    # 如果是Swift，首先语法不行，如果想要达到这个效果，只需要将Dog定义成协议，并且提供work方法列表即可
    def work_with_dog(dog):
        dog.work()
```